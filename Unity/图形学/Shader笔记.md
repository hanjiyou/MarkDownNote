# 第4章 
## 4.6坐标空间的变换
1. 已知子坐标空间C的3个坐标轴在父坐标空间P下的表示Xc、Yc、Zc，以及其原点位置Oc。给定子坐标空间的点Ac=(a,b,c)，求Mc->p如下：
![c->p变换矩阵](_v_images/20190605145820323_19819.png)
2. 对方向矢量进行坐标空间变换可以使用3X3的矩阵表示:![矢量的变换矩阵](_v_images/20190605150047361_32181.png)
3. 如果变换矩阵**是正交矩阵，则其逆矩阵=转置矩阵**（如果一个变换只存在平移和旋转，那么其逆矩阵=转置矩阵），则逆矩阵Mp->c如下：![](_v_images/20190605150505729_660.png)

## 4.7 法线变换

1. 法线不能直接使用和顶点相同的变换矩阵，需要特殊的变换矩阵
2. 经过推导，法线的变换矩阵为顶点矩阵的逆转置矩阵

# 第6章 Unity中的基础光照

## 6.1 光源
### 6.1.1 光源简介
l:光源方向 n:表面法线 a:n和l的夹角
1. **辐照度**：对于平行光来说，辐照度可通过计算在垂直于l(光源方向)的单位面积
上单位时间内穿过的能力来得到。
2. 辐照度是和照射到物体表面时光线之间的距离d/cos a成反比的，即辐照度与cos a成正比。而cos a可以用i.n来得到  
![](_v_images/20190530150709431_28554.png)
### 6.1.2 吸收和散射
1. 光源与物体相交产生的结果只有两个:散射、吸收
2. **散射**分为:
* 折射/投射：散射到物体内部
* 反射：散射到物体外部
3. **高光反射(specular)**：表示物体表面是如何反射光线的
4. **漫反射(diffuse)**：表示有多少光线会被折射、吸收和散射出表面
5. **出射度(exitance)**：根据入射光线的数量和方向，计算出射光线的数量和方向。辐照度和出射度之间满足线性关系，他们之间的比值就是**材质的漫反射和高光反射属性**
### 6.1.3 着色
1. **着色**：根据材质属性（漫反射属性等）、光源信息（方向、辐照度），使用一个等式去计算沿着某个观察方向的出射度的过程。这个等式就是**光照模型（Lighting Model）**
### 6.1.4 BRDF光照模型
1. BRDF（Bidirectional Reflectance Distribution Function）用于当光线从某个方向照射到一个表面时，计算有多少光线被反射？反射的方向有哪些。
## 6.2 标准光照模型
1. 概念
* 由裴祥风提出的只关心直接光照的模型，也被成为Phong光照模型。
* 组成部分：
    * 自发光(emmisive) 模拟直接进入摄像机的部分光源。等式如下：**C emmissive=M emissive**
    * 高光反射(specular) 
        1. 计算高光反射所需的信息较多，如:n、v、i、**r(反射方向)**。反射方向可通过其他信息得到：**r=2(n.i)n-i**
        2. **Phong模型**  
        **C specular=(C light.M specular)max(0,v.r)^M gloss**。其中,M gloss是材质的光泽度/反光度。它用于控制高光区域的亮点有多宽，M gloss越大，亮点越小。M spcular是材质的高光反射颜色。
        3. **Blinn模型**（不需要计算反射）  
        也被称为Blinn-Phong光照模型。引用新矢量h，**h=(v+i)/(|v+i|)**，光照模型公式如下：**C spcular=(C light.M specular)max(0,n.h)^M gloss**
        4. 两者区别：  
        如果摄像机和光源距离模型足够远，则Blinn会快于Phong模型，因为此时可以认为v、i是定值，则h是常量。但v、i不是定值时，Phong会更快一些。
    * 漫反射(diffuse) 
         1. 用于被表面随机散射到各个方向的辐射度进行建模。视角位置不重要，因为在任何反射方向上分布都是一样，但是入射光线的角度很重要。
         2. 漫反射符合**兰伯特定律（Lambert's law）**：反射光线的强度与cos a成正比。计算公式如下：**C diffuse=(C light.M diffuse)max(0,n.i)**
    * 环境光(ambient) 模拟间接光照，是一个全局变量，即所有物体都使用这个环境光。等式如下: **C ambient=g ambient**
### 6.2.1 逐像素或逐顶点
1. 计算所在位置
* 逐像素光照：在片元着色器中计算光照模型
* 逐顶点光照：在顶点着色器中计算
2. 计算法线
* Phong着色：在逐像素光照中，在面片之间的对顶点法线进行插值的技术。
* 高洛德着色：顶点光照中，对顶点法线进行插值的技术。
3. 区别
* 顶点数目远小于像素，因为逐顶点光照计算量远小于逐像素光照
* 逐顶点光照依赖于**线性插值**，因此如果光照模型中有非线性的计算时，逐顶点光照就会有问题：渲染图元内部对顶点颜色进行插值，导致图元内的颜色总是暗于顶点出最高颜色值，某些情况会产生棱角现象。
## 6.3 实现漫反射光照模型
注:为了防止点击结果为负，除了使用max(0,x)截取外，还可以使用saturate(x)会把x截取到[0,1]范围内，如果x是矢量，会对其每个分量进行这样的操作
### 6.3.1 半兰伯特光照模型
1. 如果使用原兰伯特光照模型，背光面点积结果全被映射到0值处。则看不出明暗变化，像个平面一样。
2. 半兰伯特光照模型公式如下:C diffuse=(C light.M diffuse)(a(n.i)+p)。a和p一般默认为0.5
## 6.4 使用Unity内置函数
*想使用下面的函数，应引入内置文件lighting.cginc*
1. 法线转换函数o->w：**UnityObjectToWorldNormal**(normal)
2. 观察方向o->w: **WorldSpaceViewDir()/UnityWorldSpaceViewDir()/ObjSpaceViewDir()**
输入模型返回世界空间的观察方向/输入世界空间坐标，返回世界空间观察/输入模型返回模型
3. 光照方向o->w：**WorldSpaceLightDir()/UnityWorldSpaceLightDir()/ObjSpaceLightDir()**同2
4. 方向矢量o->w： **UnityObjectToWorldDir()**，w->o：UnityWorldToObjectDir()
# 第7章 基础纹理
*注意：*
1. 语义区分大小写，大小写不对会导致严重错误。
## 7.1 概念
1. **纹理映射技术**：使用纹理映射技术，把图黏在模型表面，**逐纹素**地控制模型的颜色。
2. **纹理映射坐标**：建模时，通常利用纹理展开技术把纹理映射坐标存储在每个顶点上。定义该顶点在纹理中对应的2D坐标。使用二维变量(u,v)来表示。因此纹理映射坐标也被称为**uv坐标**。一般会被归一化到[0,1]范围内。
3. 纹理的两种模型
* Wrap Mode:平铺模式，有Repeat、Clamp两种。Repeat是忽略整数部分，直接使用小数部分进行采样，得到的结果是纹理将不断重复；Clamp模式下，如果uv>1那么会截取到1，uv<0会截取到0。
* Filter Mode:滤波模式，有Point,Bilinear以及Trilinear三种。得到的效果依次提升，耗费性能也增大。纹理缩放更复杂，最常用的方法是**多级渐远纹理技术**，形成一个图像金字塔，空间换时间，通常多占用33%的内存。纹理导入面板勾选**Generate Mip Maps**即可开启多级渐远纹理
    * **Point模式** 使用最近邻滤波，放大或缩小时，采样的像素只有一个，因此图像看起来有**像素风格**，然后对它们进行线性插值混合后得到最终像素。
    * **Bilinear模式**  使用线性滤波，对于每个目标像素找附近4个邻近像素线性插值后得到最终像素，因此图像**看起来模糊**了。通常选择该模式
    * **Trilinear模式** 和Bilinear几乎一样，只是还会在多级渐远纹理之间进行混合。如果纹理没有使用多级渐远，则两者相同。
4. 内置函数
* `uv=TRANSFORM_TEX(texcoord,_MainTex)` 获取纹理坐标
## 7.2  凹凸映射
1. 两种进行凹凸映射的方法：
* 高度纹理/高度映射：存储强度值（intensity）,表示表面海拔，颜色越深越凹，越浅越高
* 法线纹理：存储表面的法线方向。由于法线范围[-1,1],像素范围[0,1],因此将法线映射到纹理像素到公式为：**pixel=(normal+1)/2**，反之，纹理采样时，像素到法线到映射公式为：**normal=pixelX2-1**。法线纹理又分为两种
    * 模式空间的法线纹理：存储模型空间的**绝对法线信息**。优点：1.简单直观，计算量更少。2.尖锐处，突变较少，即可提供平滑边界。
    * 切线空间的法线纹理：存储切线空间的**相对法线信息**，切线空间原点为顶点，x:切线，z:法线，y：z叉乘x又叫副切线或副法线。优点：1.自由度很高，记录相对法线信息，即即便把该纹理应用到完全不同的网格，也能得到合理的结果。2.可进行uv动画。3.可重用法线纹理。4.可压缩，即可省略z，只存储xy，通过xy推导z。模型空间的纹理不行。
2. 法线纹理类型一般选择**Normal Type**，此时想要获取法线纹理对应的法线，不能通过反映射公式，需要通过**3=UnpackNormal(4)**函数
## 7.3 渐变纹理(控制漫反射)
1. 渐变纹理一般是**横向一维纹理**，因此纹理采样时y和x一致即可。一般渐变纹理的wrapMode模式需要设置为**clamp**，防止出现超过[0,1]范围的采样。
2. 渐变纹理采样方法：**tex2D(_RampTex,fixed2(halfLambert,halfLambert))**
3. fixed4=tex2D(tex,uv)
## 7.4 遮罩纹理(mask texture)
*注意：顶点着色器能使用的插值寄存器是有限的，一般遮罩纹理是指高光反射遮罩。*
1. 前提：之前的实现，都是把高光反射应用到模型表面的所有地方，即所有像素都使用同样大小的高光强度和高光指数。有时希望模型某些区域反光强烈，某些区域弱一些。因此使用一张遮罩纹理来控制光照。使用其中**某个/某几个通道值**与某种表面属性进行相乘，**当该通道为0时，可保证模型表面不受该属性影响**。使美术人员更精准的控制模型表面的各种性质。
2. 如果同时定义了多个纹理，我们可以只定义一个纹理属性变量_ST。这意味着，在材质面板中修改主纹理的ST会同时影响这多个纹理的采样。使用这种方式可以**节省需要存储的纹理坐标数目**，前提是这些纹理不需要进行平铺和位移操作，或者使用同一种平铺和位移。如果每个纹理都单独使用一个属性变量_ST，随着使用的纹理数目的增加，会迅速**占满顶点着色器中可以使用的插值寄存器**。
3. 遮罩纹理只需要占用纹理的一个分量，将该分量和高光反射部分进行相乘。为了充分利用，可以使用每个颜色通道来存储不同的表面属性，如：高光反射强度存储在R通道，边缘光照强度存储在G通道，自发光存储在A通道，高光反射指数存储在B通道。
# 第8章 透明效果
## 8.1 概念
1. Unity中，有两种方法实现透明效果
* 透明度测试(Alpha Test) 不能得到真正的半透明效果
    * 只要当前片元的透明度不满足条件，就会被舍弃。满足条件就按普通的不透明物体处理，即深度测试、写入等。和不透明物体最大的区别就是根据透明度来舍弃片元，得到的效果**要么是完全透明，要是完全不透明**
* 透明度混合(Alpha Blending)
    * **关闭深度写入**
    * 先进行深度测试，满足条件则使用当前片元的透明度与颜色缓冲区的值进行混合，不满足则不进行混合。
2. 渲染顺序的问题
* 由于关闭了深度写入，渲染顺序的问题就变得非常重要。
* 渲染顺序如下
    * 先渲染所有的不透明物体，并**开启他们的深度测试和深度写入**
    * 再把半透明物体按他们距离摄像机的远近进行排序，从后往前渲染，开启深度测试，**关闭深度写入**
    * 也会遇到循环重叠的半透明物体以及覆盖一半的情况。
3. 渲染队列(render queue)
* 使用**Queue标签**决定将我们的模型归于哪个渲染队列，**Unity内部使用整数索引表示每个渲染队列，索引号越小越早被渲染。**
* Unity提前定义的5个渲染队列如下:
![](_v_images/20190614115023157_19103.png)
4. 常用函数及标签
* `void clip(f4/3/2/1)` 片元着色器中使用进行透明度测试
* 几种常用标签
    * `Queue=AlphaTest/Transparent` 渲染队列标签  透明度测试/透明度混合需要指定队列为Transparent
    * `RenderType`=`TransparentCutout/Transparent` 让Unity把这个Shader归入到提前定义的组(TransparentCutout/Transparent) 中，以指明该Shader是一个使用了透明度测试/混合的Shader，常被用于着色器替换功能
    * `IgnoreProjector`=`True` 设置为True意味着这个Shader不会收到投影器Projectores的影响  
*注：1.通常透明度测试/混合会包含上述三种标签，且位置是在SubShader中  
2.LightMode标签是Pass标签的一种，只有定义了正确的LightMode才能正确得到Unity的内置光照变量，如_LightColor0*
## 8.4 透明度混合
1. 透明度混合：使用**当前片元的透明度**作为混合因子，与已经存储在颜色缓冲区的颜色值进行混合，得到新颜色。**透明度混合需要关闭深度写入，因此需要小心物体的渲染顺序**。
2. 想要实现半透效果就需要把当前颜色和颜色缓冲区的颜色进行混合，需要使用混合命令**Blend**，混合使用的函数由该指令决定，本书使用下图第二种语义（不仅设置混合因子，还自动开启混合模式）。![](_v_images/20190614165504107_8087.png)使用该语义新的颜色计算公式如下：**DstColor new=SrcAlphaXSrcColor+(1-SrcAlpha)XDstColor old**