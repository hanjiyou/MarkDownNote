#  C#基础笔记
## 1.1. 常量
### 1.1.1. 常量的种类 
1. 静态常量 const: 是指编译器在编译时候会对常量进行解析，并将常量的值替换成初始化的那个值。
2. 动态常量 readonly: 是在运行的那一刻才获得的，编译器编译期间将其标示为只读常量，而不用常量的值代替，这样动态常量不必在声明的时候就初始化，而**可以延迟到构造函数中初始化**(只能在初始化和构造中两处赋值)。
### 1.1.2. 两者的异同
1. const修饰的常量在声明的时候必须初始化;readonly修饰的常量则可以**延迟到构造函数初始化**
2. const修饰的常量在编译期间就被解析，即常量值被替换成初始化的值;readonly修饰的常量则延迟到运行的时候
3. const修饰的常量注重的是效率;readonly修饰的常量注重灵活
4. const修饰的常量**没有内存消耗**;readonly因为需要**保存常量，所以有内存消耗**
5. const只能修饰**基元类型、枚举类、或者字符串类型和(非基元类型的常量变量，但这个值应设为null)**;readonly却没有这个限制
6. const编译之后就已经是static静态字段，所以不能用static修饰const常量
7. 某个字段是引用类型，并且该字段标记为readonly时，那么**不可改变的是引用**，而非字段引用的值

## 1.2 相对路径

1. `./`:代表目前所在的目录
2. `../`：代表上一层目录
3. `/`代表根目录

## 汉字编码

1. 如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

   0xxxxxxx
   110xxxxx 10xxxxxx
   1110xxxx 10xxxxxx 10xxxxxx
   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

# 高级

## unsafe

1. **unsafe**代码介于托管代码和非托管代码之间。在clr环境中执行，但是可以直接操作内存。只要代码中包含'*'、'&'、'->'这三种指针操作符，就必须使用unsafe
2. **fixed**其实是在非安全代码下用到才会有意义的，**负责对指针所指向的“动态分配内存的对象或对象中的成员”简称“对象”进行锁定**。防止对象地址变动导致的混乱(CLR导致的)，禁止垃圾回收器重定位可移动的变量。

## Dictionary优化

1. 老版本字典，枚举做key时，每次对字典进行增删改查都会产生<u>GC</u>。

   * 原因：没传入自己的Comparer，未实现IEquatable的枚举，在调用Equals比较时 会转换成Object产生装箱操作
   * 解决办法:传入自定义的Comparer，实现IEqualityComparer<TargetEnum>接口，重写自定义的GetHashCode和Equals方法

2. 新版本字典，无论key是什么类型，在add时都会装箱成object，会产生GC

   * 内置了枚举类型的Comparer，不需要自己再重新定义comparer

   * 通过jit操作，在运行时替换成内置的无GC的GetHashCode和Equal方法

     

